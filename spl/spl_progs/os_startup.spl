// OS Startup Code for XOS

// load the exception handler
// exception handler is stored in blocks 1 and 2 in the disk
// load them to memory blocks 7 and 8
// see memory and disk organization

// format of load is load (page_number, block_number); 

load(7, 1);
load(8, 2);


// load interrupt routine 7
// I think that's HALT

load(23, 17);
load(24, 18);

// allocate PID of first process which is INIT

[READY_LIST + 0] = 0;

// memory for user processes start at block 25
// INIT code is stored in blocks 21-23 in the disk
// load the code onto memory

load(25,21); 
load(26,22); 
load(27,23); 

// page table for INIT must be set up for 
// address translation scheme to work correctly
// the list of all page tables start at memory address 1024
// page table for each process has 8 words
// so PID x 8 + 1024 gives the physical address of each process table

PTBR = 1024;
PTLR = 4;	// by default

// set up entries for page table
// first word has physical address
// second word has auxiliary information, which is
// referenced? and valid?
// four pages - three for code and one for stack

[PTBR + 0] = 25;
[PTBR + 1] = "01";	// not referenced but valid
[PTBR + 2] = 26;
[PTBR + 3] = "01";
[PTBR + 4] = 27;
[PTBR + 5] = "01";
[PTBR + 6] = 28;	// memory for stack
[PTBR + 7] = "01";

// when there are more than one process in memory, the running process is
// identified by looking at the STATE field in the Ready List of PCBs
// this fact will come in use later

[READY_LIST + 1] = 2; // set the entry for STATE as running

// breakpoints can be used for debugging

// breakpoint;

// the value of SP must be set to its starting logical address,
// which starts form the 3 * 512 = 1536)

SP = 3 * 512;

// every program in memory starts from logical address 0
// so we need IP to point to 0
// but we can't do this explicitly
// but if we put value 0 to the top of the stack,
// IRET will implicitly set IP to this value
// so we need stack of the INIT process to be assigned value 0
// each page is 512 words long, stack starts from page number 28, so

[28 * 512] = 0;

// load interrupt routine 1
// stored in disk blocks 5 and 6
// in memory stored in pages 11 and 12

load(11, 5);
load(12, 6);

// load the timer interrupt routine
// stored in disk blocks 3 and 4
// stored in pages 9 and 10 in memory

load(9, 3);
load(10, 4);

// load and set up the process structure for the second process

// set the PID of the second process as 1
[READY_LIST + 32] = 1;

// allocate space in memory
// INIT already occupies pages 25 to 28
// so we can start from 29 onwards
// find the disk block where the code for even is stored
// the basic block of the file was found to be in block 26 of the disk
// page 30 in memory will be used as stack
// anyway load her up

load(29, 27);	// we need just the code, not the data block

// page table for the process must be set up
// the starting address for page table is calculated as 1024 + PID x 8
// this becomes the value for the PTBR

alias PTBR_Process1 S0;
PTBR_Process1 = 1024 + 1 * 8;

// set up page table entries for memory page 29
// as well as one for memory page 30 (for the stack)
// there are four pages for each process
// set them all up

[PTBR_Process1 + 0] = 29; // Physical Page Number for Logical Page 0
[PTBR_Process1 + 1] = "01"; // Not referenced and Valid
[PTBR_Process1 + 2] = -1; // Invalid Page Number for Logical Page 1
[PTBR_Process1 + 3] = "00"; // Not referenced and Not Valid
// 'Not valid' because there is only one page of code
[PTBR_Process1 + 4] = -1; // Physical Page Number for Logical Page 3
[PTBR_Process1 + 5] = "00"; // Not referenced and Not Valid
[PTBR_Process1 + 6] = 30; // Physical Page Number for Logical Page 3
[PTBR_Process1 + 7] = "01"; // Not referenced and Valid

// now we need to set up all the entries in the PCB

// STATE field is set to 1 (ready)
[READY_LIST + 33] = 1;

// set the PTBR
// see the structure of the PCB and this'll be clear
[READY_LIST + 37] = PTBR_Process1;
[READY_LIST + 38] = 4; // PTLR, this is by default

// set the SP, BP fields which should be the starting
// LOGICAL address of the process stack
// logical address will be at 3(rd page) x 512
[READY_LIST + 34] = 3 * 512; // Sets the entry for BP in the PCB
[READY_LIST + 35] = 3 * 512; // Sets the entry for SP in the PCB 

// code area of the process starts from logical address 0
// so IP field is set to zero
[READY_LIST + 36] = 0;

// again, breakpoints can be used for debugging

// breakpoint;

// use ireturn to transfer control to user program
// ireturn translates to IRET machine instruction

ireturn;
